<html><head>
<title>Using the UTSA Disk Head Simulator</title></head><body>
<h1> Using the Disk Head Simulator</h1>

This document was last modified on March 2, 2004 to reflect changes made
to version 0.54.  This is the first version with a user's guide.

</p><hr>
<h1>Table of Contents</h1>

<a href="#Overview">Overview</a><br>
<a href="#Requirements">System and User Requirements</a><br>
<a href="#Starting">Starting the Simulator</a><br>
<a href="#BasicOperation">Basic Operation</a><br>
<a href="#Configuration">Configuration</a><br>
<a href="#RunsandExperiments">Runs and Experiments</a><br>
<a href="#SimulatorTime">Simulator Time</a><br>
<a href="#Distributions">Distributions</a><br>
<a href="#HeadAlgorithms">Head Algorithms</a><br>
<a href="#MovementAlgorithms">Movement Algorithms</a><br>
<a href="#LayoutAlgorithms">Layout Algorithms</a><br>
<a href="#SpecifyingBlocks">Specifying Blocks</a><br>
<a href="#SpecifyingBadBlocks">Specifying Bad Blocks</a><br>
<a href="#Running">Running the Simulator</a><br>
<a href="#Logging">Logging</a><br>
<a href="#DemoMode">Demo Mode</a><br>
<a href="#AdditionalFeatures">Additional Features</a><br>
<p>
</p><hr>
<p>
<a name="Overview"></a>
</p><h3>Overview</h3>
The Disk Head Simulator is a Java application that can be used for exploring
aspects of disk head scheduling.  It supports the standard scheduling
algorithms such as FCFS, SSTF, SCAN, LOOK, C-SCAN and C-LOOK as well as
double buffered versions of these.  Blocks to seek can be set up either
as a list in a file or generated on the fly using distributions.  These blocks
can wither be static (all arriving before the simulation starts) or can arrive
at a later time.
<p>
The time to do a seek can be set to be any linear function of the number
of cylinders to move.  The simulator supports both a uniform layout
of blocks (a fixed number of blocks per cylinder) or a zoned layout in which
the physical disk is divided into sections with different uniform layouts.
</p><p>
The simulator assumes that the operating system is doing the scheduling.
It can either assume that the operating system has complete knowledge of the
physical layout of the disk or the operating system can use a different layout.
For example, the operating systems can use LBA (logical block addressing)
in which it essentially assumes that each block is on a separate cylinder
while the physical layout is zoned.  The consequences of this mismatch
can be explored using the simulator.
</p><p>
The simulator can generate graphs and tables of statistics which can be used to
compare different disk layouts or seek algorithms.  All data and graphs
generated by the simulator can be placed in a log file in HTML format for
display or printing.
</p><p>
The simulator is available for download and is freely available.

</p><p>
</p><hr>
<p>
<a name="Requirements"></a>
</p><h3>System and User Requirements</h3>
<p>
System requirements:
</p><ul><li>
    Computer with a Java runtime environment, version 1.1 or later.<br>
    Java 1.4.2 or later is recommended.
    </li><li>The tutorial assumes that the following files have been appropriately
        installed:<tt>
        </tt><ul><li><tt>DiskHead.jar
            </tt></li><li><tt>Jeli.jar
            </tt></li><li><tt>diskheadconfig
            </tt></li><li><tt>myrun.run
            </tt></li><li><tt>myexp.exp
            </tt></li><li><tt>rundisk.bat </tt>(for Windows) or <tt>rundisk</tt> for UNIX<tt>
        </tt></li></ul>
</li></ul>
<p>
User requirements:
</p><ul><li>Familiarity with running a program in a command line environment
    </li><li>Knowledge of disk head scheduling, for example, from a few pages
        in a standard undergraduate operating systems textbook.  Examples
        include:
        <ul>
        <li> Silberschatz, Galvin and Gagne, Operating System Concepts,
             6th edition, 2002, Section 14.2, pp. 492-498.
        </li><li> Tanenbaum, Modern Operating Systems, 2nd edition, 2001,
             Section 5.4.3, pp. 318-322.
        </li><li> Nutt, Operating Systems, 3rd. edition, 2003, Section 5.5,
             pp. 182-185.
        </li><li> Stallings, Operating Systems, 3rd. edition, 1998, Section 11.5,
             pp. 463-470.
        </li></ul>
</li></ul>

If you are only interested in this simulator, you can download a zip file
<a href="http://vip.cs.utsa.edu/downloads/disk.zip">disk.zip</a>
that contains all of the files that you need.
<p>
 
<b>Running in a non-Windows environment:</b><br> 
If you installed the simulator by copying the files from a CD, the 
scripts may not have the correct permissions to run.  The <tt>convert</tt>
and <tt>rundisk</tt> files should be executable.<br>
The ASCII files distributed with this distribution are in the Windows format 
in which lines end in a carriage return followed by a line feed.  
It may be more convenient to have the carriage returns removed.
If you are running under UNIX, Linux, or Mac OSX, it
may be more convenient to have the carriage returns removed.
You can remove all of the carriage returns from these files by executing the 
<tt>convert</tt> script.
<p> 
 

<hr>
<a name="Starting"></a>
<h3>Starting the Simulator</h3>
If you are running from an image of the simulator CD, start in the
<tt>disk</tt> subdirectory of the <tt>run</tt> directory.  If you unzipped
the <b>DiskHead.zip</b> file in a single directory, start in that directory.
In either case, you can start the simulator from a command window by
executing typing <tt>rundisk</tt>.  In a Windows environment you can
also just click on the file <tt>rundisk.bat</tt>.
<p>
If you do a custom installation, you can put the jar files anywhere you
want.  Modify the <tt>rundisk.bat</tt> (Windows) or <tt>rundisk</tt>
(Unix, Linux, Mac OSX) file so that the <tt>JARDIR1</tt> or <tt>JARDIR2</tt>
variables points to the location of the jar files.
<p>
If the simulator does not start, make sure you have the Java runtime
executables in your path.  In a command window, execute:<br>
<tt>java -version</tt><br>
and make sure this displays a version later than 1.0.
<p>


</p><hr>
<a name="BasicOperation"></a>
<h3>Basic Operation</h3>

From a command
or terminal window, execute <tt>rundisk</tt>.  After a few seconds, you
should see a small window appear similar to the one below.
<p>
</p><center>
<img src="files/disk_head_0_54.gif">
<p> Figure 1: The main simulator window.
</p></center>

The main simulator window has four parts.
<p>
</p><ol>
<li>The first three lines in the window give version information.
</li><li> The <b>Quit</b> button in the upper right corner exits the simulator.
</li><li>The thin bar under the version information is a progress bar that shows
the progress of the simulator.
When the experiment is run, the upper progress bar (in red) gives the progress
of the experiment and the lower bar (in blue) gives the progress of the current
run.
</li><li>The bottom of the main window is taken up with buttons that control the
simulator.
<ul>
<li>The leftmost column of buttons control the logging features.
</li><li>The middle column displays information about the current experiment
    and results of the experiment.
</li><li>The last column is used to run the experiment.
</li></ul>
</li></ol>
When you push the large green <b>Run Experiment</b> button it splits into
two buttons:
<b>Pause Experiment</b> and <b>Abort Experiment</b>
until the experiment is complete.  When the experiment
has completed, the button changes back to its original form.
<p>
After running the experiment, the results can be displayed using the
<b>Show Table Data</b> at the top of the middle column.  This displays
information about the result of the runs.  Figure 2 shows the table
for three runs.
</p><p>
</p><center>
<img src="files/disk_table_data.gif">
<p> Figure 2: The statistics generated by the simulator.
</p></center>
<p>
The <b>Show Run Data Graph</b> displays a graphical representation of
one of the runs.  If more than one run has been made, you will be presented with
a list of runs to choose from.  After choosing one of these, a graph of the
selected run will appear.  Figure 3 below shows a graph for the SSTF algorithm
applied to the following track numbers:
</p><p>
</p><center>
<img src="files/disk_graphic_SSTF.gif">
<p> Figure 3: A graphical representation of the SSTF algorithm.
</p></center>
<p>
The data and graphics generated by the simulator can be saved in an HTML
file that can be displayed and printed by a standard browser.
See the section on <a href="#Logging">logging</a>.

</p><p>
</p><hr>
<a name="Configuration"></a>
<h3>Configuration</h3>
The default configuration file is <tt>diskheadconfig</tt> but the simulator
will use another file if it is specified on the command line when the simulator
is started.  A configuration file contains lines of keyword-value pairs.
Lines beginning with a <tt>%</tt> are treated as comments and are ignored.
The following table lists the valid keywords and the corresponding values.
<table border="1">
<tr><td>Keyword</td><td>Values</td><td>Meaning</td></tr><tr>
</tr><tr><td>user</td><td>anything</td><td>The name of the current user.
             This appears in the log file.</td></tr><tr>
</tr><tr><td>quiet</td><td>none</td>
           <td>Turns off all sounds generated by the simulator.</td></tr><tr>
</tr><tr><td>run</td><td>a filename</td><td>This is the name of a file with
          extension .run.  The extension is not listed.  Each run file used
          by the simulator must have a corresponding run line
          in the configuration file.</td></tr><tr>
</tr><tr><td>exp</td><td>a filename</td><td>
          This is the name of a file with extension .exp.  The
           extension is not listed.  Each exp file used by the simulator
           must have a corresponding run line in the configuration file.</td>
           </tr><tr>
</tr><tr><td>input</td><td>a filename</td><td>
        The name of an input file.  Each input file specified in a run or exp
        file must appear here.</td></tr><tr>
</tr><tr><td>fontsize</td><td>an integer</td><td>The default fontsize.
        This parameter is optional.</td></tr><tr>
</tr><tr><td>fontname</td><td>a font name</td><td>This must be the name of a font
       that is recognized by the Java system.  It is optional. </td></tr><tr>
</tr><tr><td>fontstyle</td><td>a font style</td>
        <td>This is either plain, bold or italics. It is optional.</td></tr><tr></tr><tr><td>logdir</td><td>a directory path</td><td>If given, this is the
      directory for storing the log file.  If not given, the log file is
      stored in the current directory.</td></tr><tr>
</tr><tr><td>logfile</td><td>a filename</td><td>
        The name of the log file.  The extension .html will be appended to
        this.  The default log file is logfile.html.</td></tr><tr>
</tr><tr><td>imagename</td><td>a filename</td><td>This is the base filename
        used for images created for the log file.  The default is gifimage.</td></tr><tr>
</tr><tr><td>datadir</td><td>a directory path</td>
        <td>If given, this is where input, run and exp file are located.
        By default, they are stored in the current directory.</td></tr><tr>
</tr><tr><td>port</td><td>an integer</td><td>
        If this value is greater than zero, remote logging will be used
        with this port.
        The default is 0.</td></tr><tr>
</tr><tr><td>standardcolors</td><td>4 integers</td><td>If given, these numbers
       affect the intensity of the colors used by the simulator.</td></tr><tr>
</tr></tbody></table>

<p>
</p><hr>
<a name="RunsandExperiments"></a>
<h3>Runs and Experiments</h3>

A run (or more precisely and experimental run)
consists of a running the simulator with a specific
set of algorithms and input data.  Three algorithms are needed to specify
a run.
<ul>
<li>The movement algorithm describes how long it takes to move from one
    track to another.  Currently, the only supported movement algorithm
    is <b>linear</b>.  A linear movement algorithm is specified by a
    constant, <tt>c</tt>, and a rate, <tt>r</tt>.
    The time to move the head a total of <tt>n</tt>
    cylinders is <tt>c + nr</tt>.
</li><li>A layout algorithm which indicates how sectors are laid out
    on the disk.  The simplest layout is <b>uniform</b> in which in 
    cylinder has the same number of sectors.
</li><li>A head algorithm specifies how to determine which block to seek to next.
    Supported algorithms include FCFS, SCAN, C-SCAN, LOOK, C-LOOK, and
    SSTF.
</li></ul>

Experimental runs are described in a file with extension <tt>.run</tt>.
This file consists of lines, each containing a keyword followed by a value
or values.  The first line of the file should contain the keyword <b>name</b>
followed by the name of the file without the <tt>.run</tt> extension.
The second line should contain the keyword <b>comment</b> followed by a comment
describing the run.  This line is not used by the simulator.
<p>
The following lines of the run file contain the following information:
<br>
<table border="1">
<tr><td>Keyword</td><td>Values</td></tr><tr>
</tr><tr><td>key</td><td>Text describing the run.
                    This is used in many of the tables to distinguish this
                    run from others.</td></tr>
<tr><td>doublebuffer</td><td>Either <b>true</b> or <b>false</b>.
             If true, new requests are put in a separator pending buffer until
             previous requests have been handled.  When the current buffer
             is empty, the pending buffer becomes the current one.
             The default value is false.</td></tr><tr>
</tr><tr><td>input</td><td>A file name.  The file contains a list of blocks to seek
             along with arrival time.  Each line of the file contains an
             integer block number and a floating point arrival time.
             Multiple input lines can be used and the associated files are
             merged.  Input files can also be combined with seek blocks
             generated by distributions as described below.</td></tr>
<tr><td>seed</td><td>An integer used to seed the random number generator
             used for the simulations.   If specified it allows
             repeated simulations to generate identical results.
             </td></tr>
<tr><td>seedtime</td><td>Either true or false. If true, the seed is generated
             from the current time (with millisecond precision) and any
             seed specified with the seed keyword is ignored.
             The default is false.</td></tr>
<tr><td>start</td><td>An integer representing a block number.  This is the
             starting block number of the disk head.  The default is 0.
             </td></tr>
<tr><td>layout</td><td>The value has one of two forms:<br>
                       uniform n, where n is an integer<br>
                       zoned n<sub>1</sub> m<sub>1</sub>
                             n<sub>2</sub> m<sub>2</sub> ... <br>
                       The first form is for a uniform layout with n blocks
                       per cylinder.
                       The second form is for a zoned layout in which
                        n<sub>i</sub> is the number of blocks per sector
                        and m<sub>i</sub> is the number of sectors in the
                        ith zone.  This represents the physical layout of the
                        disk, used to determining how long it takes to
                        perform a seek.
                        Each run file must have exactly one layout entry.
                       </td></tr>
<tr><td>oslayout</td><td>The value parameter is the same as for the layout
keyword.  If specified, this is the layout assumed by the operating system.
It is used to determine which block to seek next and where the operating
system thinks the disk head is currently positioned. It defaults to the
physical layout.
</td></tr>
<tr><td>movement</td><td>This specifies how long it takes the disk head
      to move from one cylinder to another.  The only currently supported
      movement algorithm is linear and specified by<br>
               linear n m<br>
      where n and m are integers.  The time for a seek of x cylinders
      for x greater than 0 is nx + m.  A seek of zero always takes 0 time.
      Each run file must have exactly one movement entry.
</td></tr>
<tr><td>badfraction</td><td>The value is a floating point number between 0
        and 1.  It represents the fraction of references that are to bad blocks.
        A reference to a bad block is mapped to a location given by the
        baddestination keyword.  It value defaults to 0.</td></tr>
<tr><td>baddestination</td><td>The value parameter is a distribution.
        See the section on
        <a href="#Distributions">Probability Distributions</a>
        for the format.  This entry is necessary when badfraction is not 0.
        When a bad block is referenced, this distribution is used to generate
        the actual destination.</td></tr>
<tr><td>head</td><td>The value is one of the following specifications
        that determine when block to seek next.<br>
               FCFS<br>
               SSTF<br>
               LOOK<br>
               LOOK-<br>
               CLOOK<br>
               SCAN n<br>
               SCAN- n<br>
               CSCAN n<br>
               V x y<br>
               V- x y<br>
        These are described in more detail under
        <a href="#HeadAlgorithms">Head Algorithms</a>.
</td></tr>
<tr><td>clear</td><td>This keyword does not use a value.
       The clear keyword is used in run modifications
      (described below) to remove any block requests specified in a run file
      </td></tr>
<tr><td>numblocks</td><td>The value is an integer specifying the number of
        block requests to generate from a distribution.  The four keywords
        numblocks, firstarrival, interarrival and nextblock form a set
        and must all be present to specify a set of blocks to generate.
        The blockabsolute and blockrelative are optional keywords that
        modify the set of blocks.  Multiple sets many be specified.</td></tr>
<tr><td>firstarrival</td><td>The value is a floating point number representing
        the arrival time of the first block generated in this set.</td></tr>
<tr><td>interarrival</td><td>The value is a distribution specification giving
        the interarrival time of the requested blocks.</td></tr>
<tr><td>nextblock</td><td>The value is a distribution specification
         that is used for generating the next block request.</td></tr>
<tr><td>blockabsolute</td><td>This does not take any parameters.  This is the
        default which indicates that the distribution given by the nextblock
        keyword generates absolute block numbers.</td></tr>
<tr><td>blockrelative</td><td>This does not take any parameters.
        If given, it specifies that the block numbers generated by
        the nextblock distribution are relative to the previous
        block generated.  This feature is not implemented in the 
        current version of the simulator.</td></tr>

</table>

</p><p> An experiment performs several runs and compares the results.  An
experiment is described by a file with extension .exp.  Like the run file,
it consists of   lines containing keywords and values.  The first two lines
of an experiment file contain a name and comment field similar to those of
a run file.  The name  line contains the name of the file without the <tt>.exp</tt> extension. 
The rest of the lines in an experiment file contain the keyword <b>run</b> 
followed by the name of a run file.
</p><p>
The name of the run file may be followed by any number of keyword-value pairs
that modify the run.  The keywords and values are the same as those listed in
the table.
The run modifications allow the same run file to be used several times
in the same experiment.
</p><p>
For example, suppose that the file <tt>myrun.run</tt> uses the FCFS head
movement algorithm.  The following file called <tt>myexp.exp</tt> will make
three runs, all with the same parameters but using three different head
movement algorithms:
</p><pre>name myexp
comment Three head algorithms compared
run myrun key "FCFS" 
run myrun key "SSTF" head SSTF
run myrun key "C-LOOK" head CLOOK
</pre>
The first run line has one modification, <b>key</b> while the others modify
both the <b>key</b> and the <b>head</b>.  Any modifications in the run line
of an experiment file override the corresponding value in the named
run file.

<p>
</p><hr>
<a name="SimulatorTime"></a>
<h3>Simulator Time</h3>
The simulator is event driven.  This means that the simulator program takes
action when an event occurs.  An event can either be an arrival of a new block
request or the completion of a seek.  Each event occurs at a specific time.
Time is prepresented as a floating point number greater than or equal to zero.


<p>
</p><hr>
<a name="Distributions"></a>
<h3>Probability Distributions</h3>
Three probability distributions are supported at this time.
When a probability distribution is specified in a file, it is represented
by a single line of ASCII characters.  The line starts with a word indicating
the type of distribution and is followed by either a single floating point
number representing the mean of the distribution, or in the case of the
uniform distribution two floating point numbers representing the left and
right endpoints of the interval.
<p>
The following distributions are supported:</p><p>
</p><ul>
<li>The constant distribution.  Example:<br>
   <ul>constant 23.45</ul>
    represents a constant distribution with constant value 23.45.
</li><li>The exponential distribution.  Example:<br>
   <ul>exponential 23.45</ul>
   represents the exponential distribution with mean 23.45.
</li><li>The uniform distribution.  Example:<br>
    <ul>uniform 23.45 47.89</ul>
    represents the uniform distribution in the interval [23.45,47.89]
</li></ul>



<p>
</p><hr>
<a name="HeadAlgorithms"></a>
<h3>Head Algorithms</h3>
The term <i>head algorithm</i> refers to the method the simulator uses to
decide which block to seek next.  At any given time there are a number of
pending block requests is a buffer or list.  Each algorithm is specified by
a short keyword.  Some of these require one or more arguments.
The following head algorithms are supported by the simulator:
<table border="1">
<tbody><tr><td>Algorithm</td><td>Argument types</td><td>Description</td></tr><tr>
</tr><tr><td>SCAN</td><td>integer</td><td>
The SCAN algorithm starts moving the head toward higher cylinder numbers
until it reaches the last cylinder
(given by the argument) stopping at pending blocks along the way.
It then reverses direction and stops at pending blocks on the way back,
moving al the way to cylinder 0.
</td></tr><tr>
</tr><tr><td>SCAN-</td><td>integer</td><td>
This is similar to the SCAN algorithm, but it starts moving toward lower
cylinder numbers.</td></tr><tr>
</tr><tr><td>CSCAN</td><td>integer</td><td>
This is similar to SCAN but does not stop at pending blocks on the way bak to
cylinder 0.</td></tr><tr>
</tr><tr><td>LOOK</td><td>none</td><td>
LOOK is like SCAN, but it changes direction when there are no more pending
blocks in the current direction.</td></tr><tr>
</tr><tr><td>LOOK-</td><td>none</td><td>This is like LOOK but it starts moving towards lower block numbers.</td></tr><tr>
</tr><tr><td>CLOOK</td><td>none</td><td>This is like CSCAN but it changes
directions when there are no more pending references.</td></tr><tr>
</tr><tr><td>FCFS</td><td>none</td><td>This seeks blocks in the order in which
they are requested.</TD></tr><tr>
</tr><tr><td>SSTF</td><td>none</td><td>The next block to seek is on the
cylinder closest
to the current one.</td></tr><tr>
</tr><tr><td>V</td><td>float integer</td><td>This is the Vr algorithm that
        takes two
        parameters, x and y.  x is a floating point value between 0 and 1.
        and y is an integer representing the largest block number.  This
        algorithm is a mixture of SSTF and SCAN with the x parameter
        indicating the mix.  When x = 0 the algorithm is SSTF and when x = 1
        the algorithm is SCAN. </td></tr><tr>
</tr><tr><td>V-</td><td>float integer</td><td>This is like V but starts in
the direction toward lower block numbers.</td></tr><tr>
</tr></tbody></table>
<p>
In addition, double buffering may be specified for each algorithm.

</p><hr>
<p>

<a name="MovementAlgorithms"></a>
</p><h3>Movement Algorithms</h3>
The movement algorithm determines how long it takes to move the head 
from one track to another.  The only supported movement algorithm is
<b>linear</b> in which the time to move <tt>n</tt> tracks is <tt>a + bn</tt>.
This formula is used whenever <tt>n &gt; 0</tt>.  The seek time for a seek
of length 0 is always 0.
<p>
</p><hr>
<p>

<a name="LayoutAlgorithms"></a>
</p><h3>Layout Algorithms</h3>
The layout algorithm describes how sectors are laid out on the disk.
There are two supported layouts: uniform and zoned.  A uniform layout has
a fixed number of tracks per cylinder.  Since the simulator does not take into
account rotational latency, the number of surfaces is not relevant.
A uniform layout is specified as:<br>
<tt>layout uniform n</tt><br>
where <tt>n</tt> is an integer greater than zero representing the number of
sectors (blocks) per cylinder.
<p>
In a zoned layout, the disk is divided into zones, each one having a uniform
layout.  A zoned layout is specified by giving the number of zones, <tt>n</tt>
followed by <tt>n</tt> pairs of integers, each giving the number of cylinders
in that zone and the number of blocks per cylinder for that zone.  For example,
<br>
<tt>layout zoned 3 10 8 10 16 10 24</tt><br>
would represent a disk with 3 zones, of 10 cylinders each.  The first 10
cylinders have 8 blocks per cylinder, the next 10 have 16 blocks per
cylinder and the last 10 have 24 blocks per cylinder.
</p><p>
The simulator allows for two different layouts, one the physical layout
of the disk and the other being the logical view of the disk by the
operating system.  By default these are the same, but the layout as seen by the
operating system may be set independently with the <tt>oslayout</tt>
keyword.  For example<br>
<tt>layout zoned 3 10 8 10 16 10 24</tt><br>
<tt>oslayout uniform 16</tt><br>
indicates that the physical disk is zoned as above, but the operating system
thinks that it is uniform.
</p><p>
The operating systems layout is used to determine the next block to seek
while the physical layout is used (along with the movement algorithm)
to determine how long it takes to perform the seek.

</p><p>
</p><hr>
<p>

<a name="SpecifyingBlocks"></a>
</p><h3>Specifying Blocks to Seek</h3><p>
The head algorithm is used to decide which block to seek next from a list of
pending block requests.
The simulator uses two methods for generating these block requests.
For a short list of requests, the simplest methods is to just specify each
requested block number along with the time at which the request is made.
Use the <b>input</b> keyword with the name of a file as its one value to
specify a file containing such a list.  The format of this file is a 
sequence of lines, each containing a time (floating point value)
followed by a block number (an integer).  The lines of this file do not have
to be in any particular order.  More than one input file may be specified
and you can specify both input files along with distributions described
below.
</p><p> An alternative to presenting a list of block numbers is to have the 
simulator generate block numbers using distributions.  A collection of block
numbers is specified with distributions by specifying four keyword-value
pairs: </p><p>
<table border="1">
<tbody><tr><td>Keyword</td><td>Value</td></tr>
<tr><td>numblocks</td><td>An integer specifying how many block requests
                          will be generated.</td></tr>
<tr><td>firstarrival</td><td>A floating point value indicating the time at
        which the first of these blocks arrives.</td></tr>
<tr><td>interarrival</td><td>A distribution giving the interarrival times of
        the generated blocks.</td></tr><tr>
</tr><tr><td>nextblock</td><td>A distribution used to generate the block request.
        </td></tr>
</tbody></table>
</p><p>
The four keyword-value pairs may occur in any order.  Multiple distributions
of block requests can be used by repeating these four keyword-value pairs.
</p><p>
If used in a run modification, the input file or distribution specifications
add additional block requests to those specified in the run file.  To clear
all block request specifications, use the keyword <b>clear</b>.



</p><p>
</p><hr>
<a name="SpecifyingBadBlocks"></a>
<h3>Specifying Bad Blocks</h3>
Some disk drives automatically map bad sectors into sectors reserved for that
purpose.  When this happens, the operating system thinks it is accessing a
block in a location different than the actual location on the disk.  This has
two consequences.  The seek may take a different amount of time than expected
by the operating system and the choice of the next block to seek will be
based on incorrect information.  The simulator can simulate this with two
parameters, the <b>badfraction</b> and the <b>baddistribution</b>.
The badfraction is the faction of block references that are to bad or
mapped blocks.  The baddistribution tells where these bad block are mapped.

<p>
</p><hr>
<a name="Running"></a>
<h3>Running the Simulator</h3>
The main simulator window of Figure 1 is shown again below.
The three columns of buttons
control the running of the simulator.  The first column of buttons is
described in the section on <a href="#logging">logging</a>.  The other
buttons are described here.
<p>
</p><center>
<img src="files/disk_head_0_54.gif">
<p> Figure 1 (repeated): The main simulator window.
</p></center>
<p>
The large yellow button in the third column shows the name of the current
experiment.
If more than one experiment was specified in the configuration file,  pushing
this button changes to another experiment.
Pushing the large green <b>Run Experiment</b> runs the current experiment.
Pushing this button splits it into two buttons:
<b>Pause Experiment</b> and <b>Abort Experiment</b>
until the experiment is complete.  When the experiment
has completed, the button changes back to its original form.
If the <b>Pause Experiment</b> button is pushed while the experiment is
running, the experiment is temporarily stopped and this button
changes into a <b>Continue Experiment</b> button.  Pushing this button
resumes the experiment.  Pushing the <b>Abort Experiment</b> button ends the
experiment and no data from the experiment is saved.
</p><p>
The remaining 6 buttons display information about completed runs.
</p><p>
The <b>Show Table Data Button</b> show a table of statistics for all of the
runs similar to the one in the figure below.
</p><p>
</p><center>
<img src="files/disk_table_data.gif">
<p> Figure 2 (repeated): The statistics generated by the simulator.
</p></center>
<p>
Each run is labeled by its key.  The top part of the table shows the three
algorithms used by this run, the layout algorithm, the seek movement 
(or head) algorithm and the seek time (or seek movement) algorithm.
Also shown are the number of seeks (Count column), the total and time seeking,
the total idle time (when no head movement is occurring) and the maximum queue
length.
</p><p>
The bottom part of the table gives detailed numeric data about the seek movement
(number of tracks moved per seek), the seek time, and the seek request
turnaround time.  This latter time is the time between when the seek request
is make and when the seek is completed.  For each of these four statistics,
the main, minimum, maximum and sample standard deviation are given.
</p><p>
The <b>Done</b> button at the bottom of the window is used to close the window.
</p><p>
The <b>Show Run Data Graph</b> allows you to select a run.
When selected, a graphic showing the head movement is displayed.  The figure
below shows the Shortest Seek Time First (SSTF) graphic corresponding to the
run in above table. 
</p><p>
</p><center>
<img src="files/disk_graphic_SSTF.gif">
<p> Figure 3 (repeated): A graphical representation of the SSTF algorithm.
</p></center>
<p> 
The horizontal direction corresponds to head position.  Each time the head 
changes direction, the trace moves down.  A tic mark appears each time a
seek position is reached that does not cause a change in direction.
The buttons on the bottom of the provide some additional features.
The <b>Hide</b> button temporarily hides the window.  It can be brought back
again using the <b>Show Run Data Graph</b> button.  The <b>Dispose</b> button
permanently destroys the window and all its resources.  If the
<b>Show Run Data Graph</b> button is used again for this run, a new window is
created.  If logging is active, the <b>Log</b> button will put a copy of this
image (without the buttons) in the log file.  The <b>Scale</b> button will
attempt to rescale the graphics so that it entirely fits in the window.
The <b>Show Data</b> button pops up the same table available
through the <b>Show Run Data Table</b> of the main simulator window.  It will
be described 
<a href="#ShowRunDataTable">later</a>.
The <b>Demo</b> button enters <b>Demo Mode</b>
for this window.  This mode is described in the section on
<a href="#DemoMode">Demo Mode</a>.  Lastly, the <b>Controls</b> window allows
you to set the scale and colors of various features of this window.
</p><p>
<a name="ShowRunDataTable"></a>
The <b>Show Run Data Table</b> button shows a detailed table of data about
all of the seeks made in the given run.  The figure below shows the table
for the SSTF run corresponding to the above graphic.
</p><p>
</p><center>
<img src="files/disk_table_data_SSTF.gif">
<p> Figure 4: The table generated by the <b>Show Run Data Table</b> button.
</p></center>
<p>
For each seek it shows the starting and ending block, the time the request
was made, the time the seek started, the time the seek ended, the time to
do the seek (the difference of the previous two entries), the 
turnaround time (between request and completion) and the size of the pending
queue when the request was made.  At the bottom of the table, the total number
of seeks for this run is shown.  Two button at the bottom of the table allow
you to hide or dispose of the window.
</p><p>
The <b>Show Run Description</b> button gives a description of the runs from
the current experiments.  This is essentially the contents of the run file
modified by the modifications in the exp file.  The table for the experiment
shown in Figure x is given in the table below. 

</p><p>
</p><center>
<img src="files/disk_run_description.gif">
<p> Figure 5: The table generated by the <b>Show Run Description</b> button.
</p></center>
<p>
</p><p>
The <b>Show Exp Description</b> button shows the contents of the exp file
for the current experiment.  The figure below shows an example.

</p><p>
</p><center>
<img src="files/disk_exp_description.gif">
<p> Figure 6: The table generated by the <b>Show Exp Description</b> button.
</p></center>
<p>
The <b>Show Info</b> button displays a window giving a log of the runs made.
It logs events (with wall clock time) such as the start and completion of
each run.  The window generated for the above run is shown below.
The <b>Scale</b> button attempts to fit all of the data in the window if there
are more lines than are currently displayed.  Otherwise there will be a scroll
bar on the right side of the window.
</p><p>
</p><center>
<img src="files/disk_info.gif">
<p> Figure 7: The table generated by the <b>Show Info</b> button.
</p></center>
<p>
The tables of data shown in Figures x, y, z, ... have a common format.  They
can all be resized.  If the data to be displayed does not fit in the current
format, scroll bars appear on the bottom or right side of the window.
At the top of each window are two small buttons on either side.
The <b>&amp;lt:</b> and <b>&amp;gtl</b> buttons will respectively decrease
or increase the size of the font.  If the <b>Clr</b> button is active it will
clear the contents of the window.  If logging is active, the <b>Log</b>
will put a copy of the table in the log file.

</p><p>
</p><hr>
<a name="Logging"></a>
<h3>Logging</h3>
The simulator can keep a log file in HTML format that can be displayed and
printed from a standard browser.  The log file is controlled by the column
of 5 buttons on the left side of the simulator main window.<p>
The name and location of the log file is controlled by <b>logfile</b> and
<b>logdir</b> configuration parameters.  The simulator will store images
in the logging directory with a name based on the <b>imagename</b>
configuration parameter.
</p><p>
You can change the name of the log and image files after the simulator starts
by using the <b>Change Log Filename</b> button.  This will allow you to change
the logging directory, the filename and the image filename.
</p><p>
Normally, when you open a new log file it will replace an existing log file
of the same name.  Pushing the <b>Replace Old Log</b> button changes it to
<b>Append To Old Log</b> and causes future opens to append to and existing
log file of the same name.  It also modifies the image file name so that 
images created do not interfere with those created previously.
</p><p>
Open the log file by pushing the <b>Open Log</b> button.  This changes the
<b>Open Log</b> button to <b>Close Log</b> so that the log can be closed.
It also changes the the buttons to <b>Log Comment</b> and <b>Stop Log</b>.
The <b>Log Table Data</b> is activated.
</p><p>
The <b>Log Comment</b> button allows you to insert a comment into the log file.
The <b>Stop Log</b> button changes to <b>Start Log</b> when pushed and allows
you to temporarily stop and restart automatic logging without closing the
log file.
</p><p>
The <b>Log Table Data</b> button inserts a table of data into the log file.
The information in this table is similar to the information displayed with
the <b>Show Table Data</b> button.
</p><p>
</p><hr>
<p>
<a name="DemoMode"></a>
</p><h3>Demo Mode</h3>
The run data graph display for each run contains a <b>Demo Mode</b> button.
When this button is pushed, demo mode for this display is entered.  Any number
of graphs for the same experiment can be simultaneously in demo mode.  When
this mode is active, a demo control window appears, similar to the one below.
<p>
</p><center>
<img src="files/disk_demo_mode.gif">
<p> Figure 8: The control panel for demo mode.
</p></center>
<p>
This control panel allows you to control the simulator time.  It contains a
<b>Start Button</b>, a <b>Time Slider</b>, a <b>Speed Slider</b>, an
<b>Update Rate</b> slider, and <b>Pause/Resume</b> button and a <b>Hide</b>
button.
Each of the sliders controls a particular quantity and consists of three
rows of widgets of the same color.  The first widget shows the value of the 
quantity being controlled.  The second row contains three buttons.  The first
button rounds the value.  The <b>Double</b> and <b>Half</b> buttons control the
upper limit of the slider value.  The third row contains the slider.
</p><p>
You can either
set it manually by moving the time slider or to automatically run the time
at a fixed rate by pushing the <b>Start Demo</b> button.  The speed at which
time progresses is controlled the <b>Speed Slider</b>.  How often the graphs
update is controlled by the last slider, labeled <b>Frames per second</b>.
Next there is the <b>Pause</b> button.  When it is pushed, the simulation time
stops and the button changes to a <b>Resume</b> button.
Lastly, the <b>Hide</b> button hides the demo control window.   You can
bring this window back by turning off and on the demo in any of the
run data graph displays.
</p><p>
</p><center>
<table>
<tbody><tr><td><img src="files/disk_demo_sstf_runni.gif"></td>
<td rowspan="3"><img src="files/disk_demo_mode_runni.gif"></td>
</tr>
<tr><td><img src="files/disk_demo_fcfs_runningif"></td></tr>
<tr><td><img src="files/disk_demo_clook_running.gif"></td></tr>
</tbody></table>
<p> Figure 9: Demo mode.
</p></center>
<p>
Figure 9 shows graph displays of three algorithms in demo mode along with
the demo control panel.  The time is paused at 44.695.  Each of the graphs
shows the state of the simulation at that time.  At the top of each graph
are tick marks in blank, green and red.  The black marks are pending requests.
The request of the current seek is shown in green.  The current head position
is shown in red.
</p><p>



</p><p>
</p><hr>
<a name="AdditionalFeatures"></a>
<h3>Additional Features</h3>
<b>Remote Logging</b>
If the remote port is set to a positive integer, and the simulator is started
from a browser, the simulator will attempt send to log file to the server using
the remote port.  This used when the simulator is run from a browser pointing to
the simulator web site.

<p>
<hr>
<p>

</body></html>
